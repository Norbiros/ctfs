from z3 import *

b = [ BitVec(f'b{i}', 8) for i in range(64) ]
def Q(off): return Concat(*reversed(b[off:off+8]))
def D(off): return Concat(*reversed(b[off:off+4]))

s = Solver()
# wszystkie 64‑bitowe
s.add(Q(0)  ^ Q(8)  == 0x56465f0f1f4e0a)
s.add(Q(16) - Q(24) == 0x44edf4edfb46ba00)
s.add(Q(40) + Q(32) == 0x9fcad8e0ceddd3d7)
s.add(Q(48) ^ Q(56) == 0xd73433748040f0c)
s.add(Q(12) + Q(4)  == 0xd1e05adedca8a89f)
s.add(Q(20) - Q(28) == 0x4b70dfd44edf4ee)
s.add(Q(44) + Q(36) == 0x96cedcce9fcad8e0)
# wszystkie 32‑bitowe
s.add(D(0)  ^ D(52) == 0x135e0d0c)
s.add(D(56) ^ D(60) == 0x183d4c3b)
s.add(D(20) ^ D(24) == 0x184f1b0c)
s.add(D(44) ^ D(48) == 0x5f020b07)

# format flagi ecsc25{...}
flag_prefix = b"ecsc25{"
for i, c in enumerate(flag_prefix):
    s.add(b[i] == c)
s.add(b[63] == ord('}'))
# wszystkie znaki drukowalne
for i in range(64):
    s.add(b[i] >= 0x20, b[i] <= 0x7e)

if s.check() == sat:
    m = s.model()
    flag = bytes([ m[b[i]].as_long() for i in range(64) ])
    print(flag.decode())
else:
    print("Brak rozwiązania")
