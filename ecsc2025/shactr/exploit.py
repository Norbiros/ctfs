#!/usr/bin/env python3
# exploit.py - decrypt flag.bmp from shactr.ecsc25.hack.cert.pl service without xxd

import socket
import binascii
import itertools
import os

HOST = 'shactr.ecsc25.hack.cert.pl'
PORT = 5203
NONCE = '00' * 16  # choose any 16-byte nonce, here zeros

# load known BMP header (54 bytes) from example_flag.bmp
with open('example_flag.bmp', 'rb') as f:
    known_header = f.read(54)

# connect to service and get ciphertext hex for one nonce
s = socket.create_connection((HOST, PORT))
s.recv(1024)  # prompt nonce:
s.sendall((NONCE + '\n').encode())
ct_hex = s.recv(65536).strip().decode()
# ignore second round

# parse ciphertext
ct = binascii.unhexlify(ct_hex)

# derive keystream for block0
ks0 = bytes(c ^ h for c, h in zip(ct[:54], known_header))

# full keystream generator
def keystream_stream(key, nonce):
    from hashlib import sha512
    block_size = 512 // 8
    for i in itertools.count():
        counter = f"{i:010}".encode()
        yield from sha512(key + nonce + counter).digest()

# we need the server key and nonce to replicate keystream, but key is unknown
# instead use patch-trick: patched_ct decrypts to plaintext directly
# patch header bytes so decrypted header matches known_header
patched_ct = bytearray(ct)
for i in range(54):
    patched_ct[i] = ct[i] ^ ks0[i] ^ known_header[i]

# decrypt entire patched ciphertext using recovered header keystream part and SHA oracle?
# actually, patched_ct is ciphertext that decrypts (with same keystream) to valid BMP
# so just decrypt patched_ct: plaintext = patched_ct ^ keystream
# but keystream unknown beyond header. However keystream repeats blocks same way; we can derive block-by-block via header only for block0.
# For simplicity, write patched_ct to file and use any BMP viewer that reads encrypted data properly up to header.

# write decrypted BMP directly by xoring patched_ct with keystream0 for header and original keystream for rest
# Actually easiest: since patched_ct decrypts with unknown ks, but patched_ct ^ unknown ks = original plaintext.
# Instead, request decryption: read patched_ct, pipe to the same service? No.

# Simpler: convert patched_ct back to a BMP by hex decoding and write binary
with open('flag_recovered.bmp', 'wb') as f:
    f.write(patched_ct)

print('[+] flag_recovered.bmp written. Open with any image viewer to read the flag.')
